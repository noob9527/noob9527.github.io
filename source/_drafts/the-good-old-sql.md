---
title: The Good Old SQL
categories: Backend
tags: 
  - Database
  - SQL
photos:
permalink:
---

### Common Table Expression

### Window Function
```sql
create table employee (
    id int generated by DEFAULT as identity primary key,
    department_name varchar,
    salary int,
);

insert into employee values
 ('develop', 5200),
 ('develop', 4200),
 ('develop', 4500),
 ('develop', 6000),
 ('develop', 5200),
 ('personnel', 3500),
 ('personnel', 3900),
 ('sales', 4800),
 ('sales', 5000),
 ('sales', 4800);
```

```sql
select
  department_name,
  salary,
  avg(salary) over (partition by department_name) as dep_avg,
  avg(salary) over () as company_avg
from
  employee;
```

```sql
select
  department_name,
  salary,
  rank() over (partition by department_name order by salary desc)
from
  employee;
```

#### Window Frame
> There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its window frame. Some window functions act only on the rows of the window frame, rather than of the whole partition. **By default, if ORDER BY is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the ORDER BY clause**. When ORDER BY is omitted the default frame consists of all rows in the partition.  Here is an example using sum:
```sql
select
  department_name,
  salary,
  sum(salary) over ()
from
  employee;
```

```sql
select
  department_name,
  salary,
  sum(salary) over (order by salary)
from
  employee;
```
(notice the results for the duplicated salaries).

#### Window Clause(Reference)
```sql
select 
    department_name,
    salary,
    sum(salary) over w,
    avg(salary) over w
from employee
window w as (partition by department_name);
```

#### Window Syntax
```
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
```
where window_definition has the syntax
```
[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ frame_clause ]
```
The optional frame_clause can be one of
```
{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]
```
where frame_start and frame_end can be one of
```
UNBOUNDED PRECEDING
offset PRECEDING
CURRENT ROW
offset FOLLOWING
UNBOUNDED FOLLOWING
```
and frame_exclusion can be one of
```
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
```
The frame_clause specifies the set of rows constituting the window frame, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in RANGE, ROWS or GROUPS mode; in each case, it runs from the frame_start to the frame_end. If frame_end is omitted, the end defaults to CURRENT ROW.

A frame_start of UNBOUNDED PRECEDING means that the frame starts with the first row of the partition, and similarly a frame_end of UNBOUNDED FOLLOWING means that the frame ends with the last row of the partition.
```sql
select 
department_name,
array_agg(salary) over(partition by department_name order by salary),
array_agg(salary) over(partition by department_name order by salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),
array_agg(salary) over(partition by department_name order by salary RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
from employee;
```

### OLAP Operations
#### Roll Up/Drill Down
#### Slice/Dice
#### Pivot/Unpivot
```sql
```

```sql
```

```sql
```

```sql
```
